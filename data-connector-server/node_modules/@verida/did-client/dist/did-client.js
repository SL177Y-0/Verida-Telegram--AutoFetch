"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DIDClient = void 0;
var did_document_1 = require("@verida/did-document");
var wallet_1 = require("./wallet");
var vda_did_resolver_1 = require("@verida/vda-did-resolver");
var vda_common_1 = require("@verida/vda-common");
var vda_did_1 = require("@verida/vda-did");
var did_resolver_1 = require("did-resolver");
var DIDClient = /** @class */ (function () {
    function DIDClient(config) {
        if (config === void 0) { config = {}; }
        this.config = config;
        if (!this.config.blockchain && !this.config.network) {
            throw new Error('Blockchain or Verida network must be specified in DIDClient configuration');
        }
        // If no blockchain anchor specified, load default for the specified Verida Network
        this.blockchainAnchor = this.config.blockchain ? this.config.blockchain : vda_common_1.DefaultNetworkBlockchainAnchors[this.config.network];
        var resolverConfig = {
            timeout: config.timeout ? config.timeout : 10000
        };
        resolverConfig.rpcUrl = this.getRpcUrl();
        var vdaDidResolver = (0, vda_did_resolver_1.getResolver)(resolverConfig);
        // @ts-ignore
        this.didResolver = new did_resolver_1.Resolver(vdaDidResolver);
    }
    DIDClient.prototype.getRpcUrl = function () {
        var rpcUrl = this.config.rpcUrl ? this.config.rpcUrl : (0, vda_common_1.getDefaultRpcUrl)(this.blockchainAnchor.toString());
        if (!rpcUrl) {
            throw new Error("Unable to locate RPC_URL for blockchain (".concat(this.blockchainAnchor, ")"));
        }
        return rpcUrl;
    };
    /**
     * Unlock save() function by providing verida signing key.
     *
     * @param veridaPrivateKey Private key of a Verida Account. Used to sign transactions in the DID Registry to verify the request originated from the DID owner / controller
     * @param callType Blockchain interaction mode. 'web3' | 'gasless'
     * @param web3Config Web3 configuration. If `web3`, you must provide `privateKey` (MATIC private key that will pay for gas). If `gasless` you must specify `endpointUrl` (URL of the meta transaction server) and any appropriate `serverConfig` and `postConfig`.
     */
    DIDClient.prototype.authenticate = function (veridaPrivateKey, callType, web3Config, defaultEndpoints) {
        this.defaultEndpoints = defaultEndpoints;
        this.veridaWallet = new wallet_1.default(veridaPrivateKey, this.blockchainAnchor.toString());
        // @ts-ignore
        if (callType == 'gasless' && !web3Config.endpointUrl) {
            throw new Error('Gasless transactions must specify `web3config.endpointUrl`');
        }
        // @ts-ignore
        if (callType == 'web3' && !web3Config.privateKey) {
            throw new Error('Web3 transactions must specify `web3config.privateKey`');
        }
        web3Config = __assign(__assign({}, (0, vda_common_1.getWeb3ConfigDefaults)(this.blockchainAnchor)), web3Config);
        // @ts-ignore
        var rpcUrl = web3Config.rpcUrl || this.config.rpcUrl;
        if (callType == 'web3' && !rpcUrl) {
            throw new Error('Web3 transactions must specify `web3config.rpcUrl`');
        }
        var _web3Config = callType === 'gasless' ?
            web3Config :
            __assign(__assign({}, web3Config), { rpcUrl: rpcUrl });
        this.vdaDid = new vda_did_1.VdaDid({
            identifier: this.veridaWallet.did,
            signKey: this.veridaWallet.privateKey,
            blockchain: this.blockchainAnchor,
            callType: callType,
            web3Options: _web3Config
        });
    };
    DIDClient.prototype.authenticated = function () {
        return this.veridaWallet !== undefined;
    };
    DIDClient.prototype.getDid = function () {
        // Add the network into the DID, if not specified
        if (this.veridaWallet === undefined) {
            return undefined;
        }
        if (this.veridaWallet.did.substring(0, 10) == 'did:vda:0x') {
            return this.veridaWallet.did.replace("did:vda:", "did:vda:".concat(this.blockchainAnchor.toString(), ":"));
        }
        return this.veridaWallet.did;
    };
    DIDClient.prototype.getPublicKey = function () {
        if (this.veridaWallet !== undefined) {
            return this.veridaWallet.publicKey;
        }
        return undefined;
    };
    /**
     * Destroy this DID
     *
     * Note: This can not be reversed and is written to the blockchain
     */
    DIDClient.prototype.destroy = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.authenticated()) {
                            throw new Error("Unable to save DIDDocument. No private key.");
                        }
                        return [4 /*yield*/, this.vdaDid.delete()];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Save DIDDocument to the chain
     *
     * @param document Updated DIDDocuent
     * @returns true if success.
     */
    DIDClient.prototype.save = function (document) {
        return __awaiter(this, void 0, void 0, function () {
            var existingDoc, err_1, endpointResponse, endpoints, err_2, doc, err_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.authenticated()) {
                            throw new Error("Unable to save DIDDocument. No private key.");
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.get(document.id)];
                    case 2:
                        existingDoc = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        err_1 = _a.sent();
                        if (!err_1.message.match('DID resolution error')) {
                            throw err_1;
                        }
                        return [3 /*break*/, 4];
                    case 4:
                        if (!!existingDoc) return [3 /*break*/, 9];
                        // Need to create the DID Doc
                        if (!this.defaultEndpoints || this.defaultEndpoints.length === 0) {
                            throw new Error('Default DID Document endpoints not specified');
                        }
                        endpoints = this.defaultEndpoints.map(function (item) {
                            return "".concat(item).concat(document.id);
                        });
                        _a.label = 5;
                    case 5:
                        _a.trys.push([5, 7, , 8]);
                        return [4 /*yield*/, this.vdaDid.create(document, endpoints)];
                    case 6:
                        endpointResponse = _a.sent();
                        return [3 /*break*/, 8];
                    case 7:
                        err_2 = _a.sent();
                        if (err_2.message == 'Unable to create DID: All endpoints failed to accept the DID Document') {
                            this.endpointErrors = this.vdaDid.getLastEndpointErrors();
                        }
                        throw err_2;
                    case 8: return [3 /*break*/, 13];
                    case 9:
                        doc = document.export();
                        document.setAttributes({
                            // Set updated timestamp
                            updated: document.buildTimestamp(new Date()),
                            // Increment version number
                            versionId: doc.versionId + 1
                        });
                        _a.label = 10;
                    case 10:
                        _a.trys.push([10, 12, , 13]);
                        return [4 /*yield*/, this.vdaDid.update(document, this.veridaWallet.privateKey)];
                    case 11:
                        endpointResponse = _a.sent();
                        return [3 /*break*/, 13];
                    case 12:
                        err_3 = _a.sent();
                        if (err_3.message == 'Unable to update DID: All endpoints failed to accept the DID Document') {
                            this.endpointErrors = this.vdaDid.getLastEndpointErrors();
                        }
                        throw err_3;
                    case 13: return [2 /*return*/, endpointResponse];
                }
            });
        });
    };
    DIDClient.prototype.getLastEndpointErrors = function () {
        return this.endpointErrors ? this.endpointErrors : {};
    };
    /**
     * Get original document loaded from blockchain. Creates a new document if it didn't exist
     *
     * @returns DID Document instance
     */
    DIDClient.prototype.get = function (did) {
        return __awaiter(this, void 0, void 0, function () {
            var resolutionResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.didResolver.resolve(did.toLowerCase())];
                    case 1:
                        resolutionResult = _a.sent();
                        if (resolutionResult.didResolutionMetadata && resolutionResult.didResolutionMetadata.error) {
                            throw new Error("DID resolution error (".concat(resolutionResult.didResolutionMetadata.error, "): ").concat(resolutionResult.didResolutionMetadata.message, " (").concat(did, ")"));
                        }
                        return [2 /*return*/, new did_document_1.DIDDocument(resolutionResult.didDocument)];
                }
            });
        });
    };
    return DIDClient;
}());
exports.DIDClient = DIDClient;
//# sourceMappingURL=did-client.js.map