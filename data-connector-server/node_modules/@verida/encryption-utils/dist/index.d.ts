/**
 * Utilizes `tweetnacl` for symmetric and asymmetric encryption.
 *
 * Utilizes `keccak256` algorithm to hash signed data and `secp256k1` signature algorithm for the resulting signature.
 */
export default class EncryptionUtils {
    static symEncryptBuffer(data: any, keyUint8Array: Uint8Array): string;
    static symDecryptBuffer(messageWithNonce: any, keyUint8Array: Uint8Array): Uint8Array;
    static symEncrypt(data: any, keyUint8Array: Uint8Array): string;
    static symDecrypt(messageWithNonce: any, keyUint8Array: Uint8Array): any;
    static asymEncrypt(data: any, secretOrSharedKey: Uint8Array): string;
    static asymDecrypt(messageWithNonce: any, secretOrSharedKey: Uint8Array): any;
    static sharedKey(publicKeyBytes: Uint8Array, privateKeyBytes: Uint8Array): Uint8Array;
    static randomKey(length: number): Uint8Array;
    static randomKeyPair(): import("tweetnacl").BoxKeyPair;
    static signData(data: any, privateKeyBytes: Uint8Array): string;
    /**
     *
     * @param data
     * @param signature
     * @param publicKey Hex encoded public key or public key in shortened address format
     * @returns
     */
    static verifySig(data: any, signature: string, publicKeyOrAddress: string): boolean;
    static getSigner(data: any, signature: string): string;
    static decodeBase64(data: any): Uint8Array;
    static encodeBase64(data: any): string;
    static hash(data: any): string;
    static hashBytes(data: any): Uint8Array;
    static base58ToHex(b58: string): Uint8Array;
    static hexToBase58(hex: string): string;
    static hexToBytes(hex: string): Uint8Array;
    static bytesToHex(bytes: Uint8Array): string;
    static publicKeyToAddress(publicKeyHex: string): string;
}
