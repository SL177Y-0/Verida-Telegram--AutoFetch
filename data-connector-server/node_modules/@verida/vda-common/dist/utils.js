"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getVeridaSign = exports.getVeridaSignWithNonce = exports.mapDidNetworkToBlockchainAnchor = exports.interpretIdentifier = void 0;
var ethers_1 = require("ethers");
var encryption_utils_1 = __importDefault(require("@verida/encryption-utils"));
var types_1 = require("@verida/types");
var computeAddress = ethers_1.utils.computeAddress, getAddress = ethers_1.utils.getAddress, solidityPack = ethers_1.utils.solidityPack;
function interpretIdentifier(identifier) {
    var id = identifier;
    var networkString = undefined;
    if (id.startsWith("did:vda")) {
        id = id.split("?")[0];
        var components = id.split(":");
        id = components[components.length - 1];
        if (components.length >= 4) {
            networkString = components.splice(2, components.length - 3).join(":");
        }
    }
    if (!networkString) {
        throw new Error('Unable to locate network');
    }
    var network = mapDidNetworkToBlockchainAnchor(networkString);
    if (id.length > 42) {
        return { address: computeAddress(id), publicKey: id, network: network };
    }
    else {
        return { address: getAddress(id), network: network }; // checksum address
    }
}
exports.interpretIdentifier = interpretIdentifier;
/**
 * Map the network part of the DID to the BlockchanAnchor.
 * @dev Get the `BlockchainAnchor` type from the `BlockchainAnchor` string or chain strings created in the previous version.
 * This function is back-ward compatiblity.
 * There are DIDs such as `did:vda:mainnet:0x....` and `did:vda:testnet:0x...` that were created in the previous version
 * @param networkString
 * @returns
 */
function mapDidNetworkToBlockchainAnchor(networkString) {
    var network;
    // Convert `network` to EnvironmentType
    if ((networkString === null || networkString === void 0 ? void 0 : networkString.toLowerCase()) == 'mainnet') {
        network = types_1.BlockchainAnchor.POLPOS;
    }
    else if ((networkString === null || networkString === void 0 ? void 0 : networkString.toLowerCase()) == 'testnet') {
        network = types_1.BlockchainAnchor.POLAMOY;
    }
    else {
        network = Object.values(types_1.BlockchainAnchor)
            .find(function (value) { return value.toLowerCase() === networkString.toLowerCase(); });
    }
    return network;
}
exports.mapDidNetworkToBlockchainAnchor = mapDidNetworkToBlockchainAnchor;
function getVeridaSignWithNonce(rawMsg, privateKey, nonce) {
    rawMsg = solidityPack(['bytes', 'uint256'], [rawMsg, nonce]);
    return (0, exports.getVeridaSign)(rawMsg, privateKey);
}
exports.getVeridaSignWithNonce = getVeridaSignWithNonce;
var getVeridaSign = function (rawMsg, privateKey) {
    var privateKeyArray = new Uint8Array(Buffer.from(privateKey.slice(2), 'hex'));
    return encryption_utils_1.default.signData(rawMsg, privateKeyArray);
};
exports.getVeridaSign = getVeridaSign;
//# sourceMappingURL=utils.js.map