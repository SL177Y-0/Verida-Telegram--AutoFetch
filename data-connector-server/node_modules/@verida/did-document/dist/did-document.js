"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var encryption_utils_1 = require("@verida/encryption-utils");
var helpers_1 = require("./helpers");
var types_1 = require("@verida/types");
var vda_common_1 = require("@verida/vda-common");
var types_2 = require("@verida/types");
var _ = require('lodash');
var DIDDocument = /** @class */ (function () {
    /**
     * Force lower case DID as we can't guarantee the DID will always be provided with checksum
     *
     * @param doc - this value can be a DocInterface or DID.
     */
    function DIDDocument(doc, publicKeyHex) {
        this.errors = [];
        if (typeof (doc) == 'string') {
            // We are creating a new DID Document
            // Make sure we have a public key
            if (!publicKeyHex || publicKeyHex.length != 132) {
                throw new Error('Unable to create DID Document. Invalid or non-existent public key.');
            }
            var did = doc.toLowerCase();
            this.doc = {
                id: did,
                created: this.buildTimestamp(new Date()),
                updated: this.buildTimestamp(new Date()),
                controller: did,
                versionId: 0
            };
            var _a = (0, vda_common_1.interpretIdentifier)(this.doc.id), address = _a.address, network = _a.network;
            var blockchainAnchor = (0, vda_common_1.mapDidNetworkToBlockchainAnchor)(network ? network.toString() : 'mainnet');
            var chainId = blockchainAnchor ? vda_common_1.BLOCKCHAIN_CHAINIDS[blockchainAnchor] : vda_common_1.BLOCKCHAIN_CHAINIDS[types_2.BlockchainAnchor.POLPOS];
            // Add default signing key
            this.doc.assertionMethod = [
                "".concat(this.doc.id, "#controller"),
                this.doc.id
            ];
            this.doc.verificationMethod = [
                // From vda-did-resolver/resolver.ts #322
                {
                    id: "".concat(this.doc.id, "#controller"),
                    type: types_1.VerificationMethodTypes.EcdsaSecp256k1RecoveryMethod2020,
                    controller: this.doc.id,
                    blockchainAccountId: "@eip155:".concat(chainId, ":").concat(address),
                },
                {
                    id: this.doc.id,
                    type: "EcdsaSecp256k1VerificationKey2019",
                    controller: this.doc.id,
                    publicKeyHex: (0, helpers_1.strip0x)(publicKeyHex)
                }
            ];
            this.doc.authentication = [
                "".concat(this.doc.id, "#controller"),
                "".concat(this.doc.id)
            ];
        }
        else {
            doc.id = doc.id.toLowerCase();
            if (!doc.versionId) {
                doc.versionId = 0;
            }
            this.doc = doc;
        }
    }
    Object.defineProperty(DIDDocument.prototype, "id", {
        get: function () {
            return this.doc.id;
        },
        enumerable: false,
        configurable: true
    });
    DIDDocument.prototype.getErrors = function () {
        return this.errors;
    };
    /**
     * Not used directly, used for testing
     *
     * @param contextName string
     * @param keyring Keyring
     * @param privateKey Private key of the DID that controls this DID Document
     * @param endpoints Endpoints
     */
    DIDDocument.prototype.addContext = function (network, contextName, keyring, privateKey, endpoints) {
        return __awaiter(this, void 0, void 0, function () {
            var contextHash, keys, didAddress, proofString, privateKeyArray, proof;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // Remove this context if it already exists
                        this.removeContext(contextName, network);
                        contextHash = DIDDocument.generateContextHash(this.doc.id, contextName);
                        // Add services
                        this.addContextService(network, contextHash, types_1.SecureContextEndpointType.DATABASE, endpoints.database.type, endpoints.database.endpointUri);
                        this.addContextService(network, contextHash, types_1.SecureContextEndpointType.MESSAGING, endpoints.messaging.type, endpoints.messaging.endpointUri);
                        if (endpoints.storage) {
                            this.addContextService(network, contextHash, types_1.SecureContextEndpointType.STORAGE, endpoints.storage.type, endpoints.storage.endpointUri);
                        }
                        if (endpoints.notification) {
                            this.addContextService(network, contextHash, types_1.SecureContextEndpointType.NOTIFICATION, endpoints.notification.type, endpoints.notification.endpointUri);
                        }
                        return [4 /*yield*/, keyring.getKeys()
                            // Generate an address representation of the DID (to save storage)
                        ];
                    case 1:
                        keys = _a.sent();
                        didAddress = this.id.match(/0x[0-9a-z]*/i)[0].toLowerCase();
                        proofString = "".concat(didAddress).concat(keys.signPublicAddress).toLowerCase();
                        privateKeyArray = new Uint8Array(Buffer.from(privateKey.slice(2), "hex"));
                        proof = encryption_utils_1.default.signData(proofString, privateKeyArray);
                        // Add keys to DID document
                        this.addContextSignKey(network, contextHash, keys.signPublicKeyHex, proof);
                        this.addContextAsymKey(network, contextHash, keys.asymPublicKeyHex);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Remove the context from the DID document
     *
     * @param contextName
     * @param network
     * @returns
     */
    DIDDocument.prototype.removeContext = function (contextName, network) {
        var _this = this;
        var contextHash = DIDDocument.generateContextHash(this.doc.id, contextName);
        if (!this.doc.verificationMethod) {
            return false;
        }
        var networkString = network ? "network=".concat(network.toString(), "&") : '';
        var contextSignId = "".concat(this.doc.id, "\\?").concat(networkString, "context=").concat(contextHash, "&type=sign");
        var contextAsymId = "".concat(this.doc.id, "\\?").concat(networkString, "context=").concat(contextHash, "&type=asym");
        if (!this.doc.verificationMethod.find(function (entry) { return entry.id.match(contextSignId); })) {
            if (networkString && network == types_1.Network.MYRTLE) {
                // Old Myrtle DID's don't specify the network, so if we have Myrtle
                // network, attempt to find context config that has no network specified
                return this.removeContext(contextName);
            }
            return false;
        }
        // Remove signing key and asymmetric key
        this.doc.verificationMethod = this.doc.verificationMethod.filter(function (entry) {
            return !entry.id.match(contextSignId) && !entry.id.match(contextAsymId);
        });
        this.doc.assertionMethod = this.doc.assertionMethod.filter(function (entry) {
            return (entry !== "".concat(_this.doc.id, "?").concat(networkString, "context=").concat(contextHash, "&type=sign") &&
                entry !== "".concat(_this.doc.id, "?").concat(networkString, "context=").concat(contextHash, "&type=asym"));
        });
        this.doc.keyAgreement = this.doc.keyAgreement.filter(function (entry) {
            return entry !== "".concat(_this.doc.id, "?").concat(networkString, "context=").concat(contextHash, "&type=asym");
        });
        // Remove services
        this.doc.service = this.doc.service.filter(function (entry) {
            return !entry.id.match("".concat(_this.doc.id, "\\?").concat(networkString, "context=").concat(contextHash));
        });
        return true;
    };
    DIDDocument.prototype.setAttributes = function (attributes) {
        for (var attribute in attributes) {
            // @ts-ignore
            this.doc[attribute] = attributes[attribute];
        }
    };
    DIDDocument.prototype.import = function (doc) {
        doc.id = doc.id.toLowerCase();
        this.doc = doc;
    };
    DIDDocument.prototype.export = function () {
        return this.doc;
    };
    DIDDocument.prototype.addContextService = function (network, contextHash, endpointType, serviceType, endpointUris) {
        if (!this.doc.service) {
            this.doc.service = [];
        }
        this.doc.service.push({
            id: "".concat(this.doc.id, "?network=").concat(network.toString(), "&context=").concat(contextHash, "&type=").concat(endpointType),
            type: serviceType,
            // @ts-ignore
            serviceEndpoint: endpointUris
        });
    };
    DIDDocument.prototype.addContextSignKey = function (network, contextHash, publicKeyHex, proof) {
        // Add verification method
        if (!this.doc.verificationMethod) {
            this.doc.verificationMethod = [];
        }
        var id = "".concat(this.doc.id, "?network=").concat(network.toString(), "&context=").concat(contextHash, "&type=sign");
        this.doc.verificationMethod.push({
            id: id,
            type: "EcdsaSecp256k1VerificationKey2019",
            controller: this.doc.id,
            // @ts-ignore
            proof: proof,
            publicKeyHex: (0, helpers_1.strip0x)(publicKeyHex)
        });
        // Add assertion method
        if (!this.doc.assertionMethod) {
            this.doc.assertionMethod = [];
        }
        this.doc.assertionMethod.push(id);
    };
    DIDDocument.prototype.addContextAsymKey = function (network, contextHash, publicKeyHex) {
        // Add verification method
        if (!this.doc.verificationMethod) {
            this.doc.verificationMethod = [];
        }
        var id = "".concat(this.doc.id, "?network=").concat(network.toString(), "&context=").concat(contextHash, "&type=asym");
        this.doc.verificationMethod.push({
            id: id,
            // type: "Curve25519EncryptionPublicKey",
            type: 'X25519KeyAgreementKey2019',
            controller: this.doc.id,
            publicKeyHex: (0, helpers_1.strip0x)(publicKeyHex)
        });
        // Add keyAgreement method
        if (!this.doc.keyAgreement) {
            this.doc.keyAgreement = [];
        }
        this.doc.keyAgreement.push(id);
        // Add assertion method
        if (!this.doc.assertionMethod) {
            this.doc.assertionMethod = [];
        }
        this.doc.assertionMethod.push(id);
    };
    DIDDocument.prototype.verifySig = function (data, signature) {
        var _this = this;
        if (!this.doc.verificationMethod) {
            return false;
        }
        var verificationMethod = this.doc.verificationMethod.find(function (entry) { return entry.id == _this.doc.id; });
        if (!verificationMethod || !verificationMethod.publicKeyHex) {
            return false;
        }
        return encryption_utils_1.default.verifySig(data, signature, "0x".concat(verificationMethod.publicKeyHex));
    };
    DIDDocument.prototype.verifyContextSignature = function (data, network, contextName, signature, contextIsHash) {
        if (contextIsHash === void 0) { contextIsHash = false; }
        var contextHash = contextName;
        if (!contextIsHash) {
            contextHash = DIDDocument.generateContextHash(this.doc.id, contextName);
        }
        var networkString = network ? "network=".concat(network.toString(), "&") : '';
        var publicKeyLookup = "".concat(this.doc.id, "?").concat(networkString, "context=").concat(contextHash, "&type=sign");
        var verificationMethod = this.doc.verificationMethod.find(function (entry) { return entry.id == publicKeyLookup; });
        if (!verificationMethod) {
            if (networkString && network == types_1.Network.MYRTLE) {
                // Old Myrtle DID's don't specify the network, so if we have Myrtle
                // network, attempt to find context config that has no network specified
                // @ts-ignore
                return this.verifyContextSignature(data, undefined, contextName, signature, contextIsHash);
            }
            return false;
        }
        var signPublicKey = "0x".concat(verificationMethod.publicKeyHex);
        return encryption_utils_1.default.verifySig(data, signature, signPublicKey);
    };
    DIDDocument.generateContextHash = function (did, contextName) {
        did = did.toLowerCase();
        return encryption_utils_1.default.hash("".concat(did, "/").concat(contextName));
    };
    DIDDocument.prototype.locateServiceEndpoint = function (contextName, endpointType, network) {
        var contextHash = DIDDocument.generateContextHash(this.doc.id, contextName);
        var networkString = network ? "network=".concat(network.toString(), "&") : '';
        var expectedEndpointId = "".concat(this.doc.id, "?").concat(networkString, "context=").concat(contextHash, "&type=").concat(endpointType);
        var result = this.doc.service.find(function (entry) { return entry.id == expectedEndpointId; });
        if (!result && networkString && network == types_1.Network.MYRTLE) {
            // Old Myrtle DID's don't specify the network, so if we have Myrtle
            // network, attempt to find context config that has no network specified
            return this.locateServiceEndpoint(contextName, endpointType);
        }
        return result;
    };
    DIDDocument.prototype.locateContextProof = function (contextName, network) {
        var _a;
        var did = this.doc.id;
        var contextHash = DIDDocument.generateContextHash(did, contextName);
        var networkString = network ? "network=".concat(network.toString(), "&") : '';
        var verificationMethod = (_a = this.doc.verificationMethod) === null || _a === void 0 ? void 0 : _a.find(function (item) {
            return item.id.match("".concat(did, "\\?").concat(networkString, "context=").concat(contextHash, "&type=sign"));
        });
        if (!verificationMethod && networkString && network == types_1.Network.MYRTLE) {
            // Old Myrtle DID's don't specify the network, so if we have Myrtle
            // network, attempt to find context config that has no network specified
            return this.locateContextProof(contextName);
        }
        // @ts-ignore
        if (verificationMethod && verificationMethod.proof) {
            // @ts-ignore
            return verificationMethod.proof;
        }
    };
    DIDDocument.prototype.signProof = function (privateKey) {
        if (privateKey == 'string') {
            privateKey = new Uint8Array(Buffer.from(privateKey.substr(2), 'hex'));
        }
        var proofData = this.getProofData();
        var signature = encryption_utils_1.default.signData(proofData, privateKey);
        this.doc.proof = {
            type: "EcdsaSecp256k1VerificationKey2019",
            verificationMethod: "".concat(this.doc.id),
            proofPurpose: "assertionMethod",
            proofValue: signature
        };
    };
    DIDDocument.prototype.verifyProof = function () {
        if (!this.doc.proof) {
            return false;
        }
        var signature = this.doc.proof.proofValue;
        var proofData = this.getProofData();
        return this.verifySig(proofData, signature);
    };
    DIDDocument.prototype.getProofData = function () {
        var proofData = Object.assign({}, this.doc);
        delete proofData['proof'];
        return proofData;
    };
    DIDDocument.prototype.buildTimestamp = function (date) {
        return date.toISOString().split('.')[0] + 'Z';
    };
    return DIDDocument;
}());
exports.default = DIDDocument;
//# sourceMappingURL=did-document.js.map