"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tweetnacl_1 = require("tweetnacl");
var tweetnacl_util_1 = require("tweetnacl-util");
var ethers_1 = require("ethers");
var utils_1 = require("ethers/lib/utils");
var JSONSortify = require('json.sortify');
var newSymNonce = function () { return (0, tweetnacl_1.randomBytes)(tweetnacl_1.secretbox.nonceLength); };
var newAsymNonce = function () { return (0, tweetnacl_1.randomBytes)(tweetnacl_1.box.nonceLength); };
var newKey = function (length) { return (0, tweetnacl_1.randomBytes)(length ? length : tweetnacl_1.secretbox.keyLength); };
/**
 * Utilizes `tweetnacl` for symmetric and asymmetric encryption.
 *
 * Utilizes `keccak256` algorithm to hash signed data and `secp256k1` signature algorithm for the resulting signature.
 */
var EncryptionUtils = /** @class */ (function () {
    function EncryptionUtils() {
    }
    EncryptionUtils.symEncryptBuffer = function (data, keyUint8Array) {
        var nonce = newSymNonce();
        var messageUint8 = data;
        var box = (0, tweetnacl_1.secretbox)(messageUint8, nonce, keyUint8Array);
        var fullMessage = new Uint8Array(nonce.length + box.length);
        fullMessage.set(nonce);
        fullMessage.set(box, nonce.length);
        var base64FullMessage = (0, tweetnacl_util_1.encodeBase64)(fullMessage);
        return base64FullMessage;
    };
    EncryptionUtils.symDecryptBuffer = function (messageWithNonce, keyUint8Array) {
        var messageWithNonceAsUint8Array = (0, tweetnacl_util_1.decodeBase64)(messageWithNonce);
        var nonce = messageWithNonceAsUint8Array.slice(0, tweetnacl_1.secretbox.nonceLength);
        var message = messageWithNonceAsUint8Array.slice(tweetnacl_1.secretbox.nonceLength, messageWithNonce.length);
        var decrypted = tweetnacl_1.secretbox.open(message, nonce, keyUint8Array);
        if (!decrypted) {
            throw new Error("Could not decrypt message");
        }
        return decrypted;
    };
    EncryptionUtils.symEncrypt = function (data, keyUint8Array) {
        if (typeof (data) === "undefined") {
            throw new Error("Data to encrypt is undefined");
        }
        data = (0, tweetnacl_util_1.decodeUTF8)(JSONSortify(data));
        return EncryptionUtils.symEncryptBuffer(data, keyUint8Array);
    };
    EncryptionUtils.symDecrypt = function (messageWithNonce, keyUint8Array) {
        var decrypted = EncryptionUtils.symDecryptBuffer(messageWithNonce, keyUint8Array);
        var base64DecryptedMessage = (0, tweetnacl_util_1.encodeUTF8)(decrypted);
        return JSON.parse(base64DecryptedMessage);
    };
    EncryptionUtils.asymEncrypt = function (data, secretOrSharedKey) {
        var nonce = newAsymNonce();
        var messageUint8 = (0, tweetnacl_util_1.decodeUTF8)(JSONSortify(data));
        var encrypted = tweetnacl_1.box.after(messageUint8, nonce, secretOrSharedKey);
        var fullMessage = new Uint8Array(nonce.length + encrypted.length);
        fullMessage.set(nonce);
        fullMessage.set(encrypted, nonce.length);
        var base64FullMessage = (0, tweetnacl_util_1.encodeBase64)(fullMessage);
        return base64FullMessage;
    };
    EncryptionUtils.asymDecrypt = function (messageWithNonce, secretOrSharedKey) {
        var messageWithNonceAsUint8Array = (0, tweetnacl_util_1.decodeBase64)(messageWithNonce);
        var nonce = messageWithNonceAsUint8Array.slice(0, tweetnacl_1.box.nonceLength);
        var message = messageWithNonceAsUint8Array.slice(tweetnacl_1.box.nonceLength, messageWithNonce.length);
        var decrypted = tweetnacl_1.box.open.after(message, nonce, secretOrSharedKey);
        if (!decrypted) {
            throw new Error('Could not decrypt message');
        }
        var base64DecryptedMessage = (0, tweetnacl_util_1.encodeUTF8)(decrypted);
        return JSON.parse(base64DecryptedMessage);
    };
    EncryptionUtils.sharedKey = function (publicKeyBytes, privateKeyBytes) {
        return tweetnacl_1.box.before(publicKeyBytes, privateKeyBytes);
    };
    EncryptionUtils.randomKey = function (length) {
        return newKey(length);
    };
    EncryptionUtils.randomKeyPair = function () {
        return tweetnacl_1.box.keyPair();
    };
    EncryptionUtils.signData = function (data, privateKeyBytes) {
        // Ensure deterministic order of data so signature matches regardless
        // of the attribute order
        if (data instanceof Uint8Array) { // this also covers `Buffer`
            data = ethers_1.utils.hexlify(data); // the hashing method that follows also tries to serialize strings, except when they are hex strings
        }
        else if (typeof data === 'object') {
            data = JSONSortify(data);
        }
        var messageHashBytes = EncryptionUtils.hashBytes(data);
        var signingKey = new ethers_1.utils.SigningKey(privateKeyBytes);
        var signature = signingKey.signDigest(messageHashBytes);
        return ethers_1.utils.joinSignature(signature);
    };
    /**
     *
     * @param data
     * @param signature
     * @param publicKey Hex encoded public key or public key in shortened address format
     * @returns
     */
    EncryptionUtils.verifySig = function (data, signature, publicKeyOrAddress) {
        var signerAddress = EncryptionUtils.getSigner(data, signature);
        if (signerAddress.toLowerCase() == publicKeyOrAddress.toLowerCase()) {
            return true;
        }
        var expectedAddress = ethers_1.utils.computeAddress(publicKeyOrAddress);
        return signerAddress.toLowerCase() == expectedAddress.toLowerCase();
    };
    EncryptionUtils.getSigner = function (data, signature) {
        // Ensure deterministic order of data so signature matches regardless
        // of the attribute order
        if (data instanceof Uint8Array) { // this also covers `Buffer`
            data = ethers_1.utils.hexlify(data); // the hashing method that follows also tries to serialize strings, except when they are hex strings
        }
        else if (typeof data === 'object') {
            data = JSONSortify(data);
        }
        var messageHashBytes = EncryptionUtils.hashBytes(data);
        var signerAddress = ethers_1.utils.recoverAddress(messageHashBytes, signature);
        return signerAddress;
    };
    EncryptionUtils.decodeBase64 = function (data) {
        return (0, tweetnacl_util_1.decodeBase64)(data);
    };
    EncryptionUtils.encodeBase64 = function (data) {
        return (0, tweetnacl_util_1.encodeBase64)(data);
    };
    EncryptionUtils.hash = function (data) {
        if (typeof (data) === 'string') {
            if (!(0, utils_1.isHexString)(data)) {
                data = ethers_1.utils.toUtf8Bytes(data);
            }
        }
        else {
            data = ethers_1.utils.toUtf8Bytes(JSONSortify(data));
        }
        return ethers_1.utils.keccak256(data);
    };
    EncryptionUtils.hashBytes = function (data) {
        var hash = EncryptionUtils.hash(data);
        return ethers_1.utils.arrayify(hash);
    };
    EncryptionUtils.base58ToHex = function (b58) {
        return ethers_1.ethers.utils.base58.decode(b58);
    };
    EncryptionUtils.hexToBase58 = function (hex) {
        return ethers_1.ethers.utils.base58.encode(hex);
    };
    EncryptionUtils.hexToBytes = function (hex) {
        return ethers_1.ethers.utils.arrayify(hex);
    };
    EncryptionUtils.bytesToHex = function (bytes) {
        return ethers_1.ethers.utils.hexlify(bytes);
    };
    EncryptionUtils.publicKeyToAddress = function (publicKeyHex) {
        var add = ethers_1.utils.computeAddress(publicKeyHex);
        return add;
    };
    return EncryptionUtils;
}());
exports.default = EncryptionUtils;
//# sourceMappingURL=index.js.map