import { DIDDocument as VeridaDIDDocument } from "@verida/did-document";
import { Web3CallType, DIDClientConfig, VdaDidEndpointResponses, Web3MetaTransactionConfig, Web3SelfTransactionConfigPart, IDIDClient } from "@verida/types";
export declare class DIDClient implements IDIDClient {
    private config;
    private blockchainAnchor;
    private didResolver;
    private vdaDid?;
    private veridaWallet;
    private defaultEndpoints?;
    private endpointErrors?;
    constructor(config?: DIDClientConfig);
    getRpcUrl(): string;
    /**
     * Unlock save() function by providing verida signing key.
     *
     * @param veridaPrivateKey Private key of a Verida Account. Used to sign transactions in the DID Registry to verify the request originated from the DID owner / controller
     * @param callType Blockchain interaction mode. 'web3' | 'gasless'
     * @param web3Config Web3 configuration. If `web3`, you must provide `privateKey` (MATIC private key that will pay for gas). If `gasless` you must specify `endpointUrl` (URL of the meta transaction server) and any appropriate `serverConfig` and `postConfig`.
     */
    authenticate(veridaPrivateKey: string, callType: Web3CallType, web3Config: Web3SelfTransactionConfigPart | Web3MetaTransactionConfig, defaultEndpoints: string[]): void;
    authenticated(): boolean;
    getDid(): string | undefined;
    getPublicKey(): string | undefined;
    /**
     * Destroy this DID
     *
     * Note: This can not be reversed and is written to the blockchain
     */
    destroy(): Promise<VdaDidEndpointResponses>;
    /**
     * Save DIDDocument to the chain
     *
     * @param document Updated DIDDocuent
     * @returns true if success.
     */
    save(document: VeridaDIDDocument): Promise<VdaDidEndpointResponses>;
    getLastEndpointErrors(): VdaDidEndpointResponses;
    /**
     * Get original document loaded from blockchain. Creates a new document if it didn't exist
     *
     * @returns DID Document instance
     */
    get(did: string): Promise<VeridaDIDDocument>;
}
