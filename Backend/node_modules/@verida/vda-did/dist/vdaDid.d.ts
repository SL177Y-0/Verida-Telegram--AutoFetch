import { DIDDocument } from '@verida/did-document';
import { VdaDidConfigurationOptions, VdaDidEndpointResponses } from '@verida/types';
export default class VdaDid {
    private options;
    private blockchain;
    private lastEndpointErrors?;
    constructor(options: VdaDidConfigurationOptions);
    /**
     * Publish the first version of a DIDDocument to a list of endpoints.
     *
     * If an endpoint fails to accept the DID Document, that endpoint will be ignored and won't be included in the
     * list of valid endpoints on chain.
     *
     * @param didDocument
     * @param endpoints
     * @return VdaDidEndpointResponses Map of endpoints where the DID Document was successfully published
     */
    create(didDocument: DIDDocument, endpoints: string[], retries?: number): Promise<VdaDidEndpointResponses>;
    /**
     * Publish an updated version of a DIDDocument to a list of endpoints.
     *
     * If an endpoint fails to accept the DID Document, that will be reflected in the response.
     *
     * Note: Any failed endpoints will remain on-chain and will need to have the update re-attempted or remove the endpoint from the DID Registry
     *
     * @param didDocument
     * @returns VdaDidEndpointResponses Map of endpoints where the DID Document was successfully published
     */
    update(didDocument: DIDDocument, controllerPrivateKey?: string): Promise<VdaDidEndpointResponses>;
    private deleteFromEndpoints;
    delete(): Promise<VdaDidEndpointResponses>;
    /**
     * Add a new to an existing DID
     *
     * @param endpointUri
     * @param verifyAllVersions
     */
    addEndpoint(endpointUri: string, verifyAllVersions?: boolean): Promise<void>;
    removeEndpoint(did: string, endpoint: string): Promise<void>;
    getLastEndpointErrors(): VdaDidEndpointResponses | undefined;
    private fetchDocumentHistory;
}
